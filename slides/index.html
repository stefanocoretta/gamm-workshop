<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction to GAM(M)S</title>
    <meta charset="utf-8" />
    <meta name="author" content="Dr Stefano Coretta" />
    <script src="index_files/header-attrs/header-attrs.js"></script>
    <link href="index_files/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="index_files/panelset/panelset.css" rel="stylesheet" />
    <script src="index_files/panelset/panelset.js"></script>
    <script src="index_files/freezeframe/freezeframe.min.js"></script>
    <script src="index_files/xaringanExtra-freezeframe/freezeframe-init.js"></script>
    <script id="xaringanExtra-freezeframe-options" type="application/json">{"selector":"img[src$=\"gif\"]","trigger":"click","overlay":false,"responsive":true,"warnings":true}</script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Introduction to GAM(M)S
]
.subtitle[
## Generalised Additive (Mixed) Models
]
.author[
### Dr Stefano Coretta
]
.date[
### 12-15 December 2022
]

---







```r
set.seed(8788)
x &lt;- seq(0,100,1)
y &lt;- ((runif(1, 10, 20) * x) / (runif(1, 0, 10) + x)) + rnorm(101, 0, 1)
x_1 &lt;- seq(0, 100, 1)
y_1 &lt;- ((runif(1, 10, 20) * x_1) / (runif(1, 0, 100) + x_1)) + rnorm(101, 0, 1)

sim_nl &lt;- tibble(
  x = c(x, x_1),
  y = c(y, y_1),
  group = rep(c("a", "b"), each = 101)
)

sim_nl_a &lt;- filter(sim_nl, group == "a")
```

class: center middle inverse

.f1[Time travel...]

---

layout: true

## Linear models

---

`$$y = 3 + 2x$$`

where `\(x = (2, 4, 5, 8, 10, 23, 36)\)`

---


```r
line &lt;- tibble(
  x = c(2, 4, 5, 8, 10, 23, 36),
  y = 3 + 2 * x
)
ggplot(line, aes(x, y)) +
  geom_point(size = 4) +
  labs(title = bquote(italic(y) == 3 + 2 * italic(x)))
```

&lt;img src="index_files/figure-html/homework-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
ggplot(line, aes(x, y)) +
  geom_point(colour = "gray", size = 4) +
  geom_line(colour = "red") +
  labs(title = bquote(italic(y) == 3 + 2 * italic(x)))
```

&lt;img src="index_files/figure-html/line-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

* In research contexts, we have `\(x\)` and `\(y\)`.

* For example, vowel duration and VOT, speech rate and pitch, etc.

---


```r
set.seed(4321)
x &lt;- 1:10
y &lt;- (1 + 1.5 * x) + rnorm(10, 0, 1)

line &lt;- tibble(
  x = x,
  y = y
)
ggplot(line, aes(x, y)) +
  geom_point(size = 4) +
  scale_x_continuous(breaks = 1:10) +
  labs(title = bquote(italic(y) == "?" + "?" * italic(x)))
```

&lt;img src="index_files/figure-html/sampled-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

* The formula: `\(y = \beta_0 + \beta_1x\)`
    * `\(\beta_0\)` is the **intercept**
    * `\(\beta_1\)` is the **slope**

--

* We know `\(x\)` and `\(y\)`.
    * We need to estimate `\(\beta_0\)`, `\(\beta_1\)` = `\(\hat{\beta_0}, \hat{\beta_1}\)`.

--

* We can add more predictors:
    * `\(y = \beta_0 + \beta_1x_1 + \beta_2x_2 + ... + \beta_nx_n\)`

--

* `lm(y ~ x, data)` ($y$ as a function of `\(x\)`).

---


```r
ggplot(line, aes(x, y)) +
  geom_point(size = 4) +
  geom_smooth(method = "lm", se = FALSE) +
  scale_x_continuous(breaks = 1:10) +
  labs(title = bquote({italic(y) == beta[0] + beta[1] * italic(x)} == 1 + 1.5 * italic(x)))
```

&lt;img src="index_files/figure-html/lm-plot-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
m &lt;- lm(y ~ x)
yhat &lt;- m$fitted.values
diff &lt;- y - yhat  
ggplot(line, aes(x, y)) +
  geom_segment(aes(x = x, xend = x, y = y, yend = yhat), colour = "red") +
  geom_point(size = 4) +
  geom_smooth(method = "lm", se = FALSE) +
  scale_x_continuous(breaks = 1:10) +
  labs(title = bquote(italic(y) == beta[0] + beta[1] * italic(x) + epsilon))
```

&lt;img src="index_files/figure-html/error-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

layout: false
layout: true

## LM with non-linear data

---


```r
ggplot(sim_nl_a, aes(x, y)) +
  geom_point(size = 4) +
  labs(title = "Some non-linear data")
```

&lt;img src="index_files/figure-html/plot-data-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
ggplot(sim_nl_a, aes(x, y)) +
  geom_point(size = 4) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Some non-linear data")
```

&lt;img src="index_files/figure-html/plot-lm-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
m &lt;- lm(y ~ x, data = sim_nl_a)
yhat &lt;- m$fitted.values
diff &lt;- sim_nl_a$y - yhat  
ggplot(sim_nl_a, aes(x, y)) +
  geom_segment(aes(x = x, xend = x, y = y, yend = yhat), colour = "red") +
  geom_point(size = 4) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Some non-linear data")
```

&lt;img src="index_files/figure-html/error-2-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

How to account for non-linearity in a linear model?

--

* Use **higher-degree polynomials**
    * quadratic: `\(y = \beta_0 + \beta_1x + \beta_2x^2\)`
    * cubic: `\(y = \beta_0 + \beta_1x + \beta_2x^2 + \beta_3x^3\)`
    * `\(n\)`th: `\(y = \beta_0 + \beta_1x + \beta_2x^2 + \beta_3x^3 + ... + \beta_nx^n\)`

---


```r
ggplot(sim_nl_a, aes(x, y)) +
  geom_point(size = 4) +
  geom_smooth(method = "lm", formula = y ~ x + I(x^2)) +
  labs(title = bquote(italic(y) == beta[0] + beta[1] * italic(x) + beta[2] * italic(x) ^ 2))
```

&lt;img src="index_files/figure-html/2-poly-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
ggplot(sim_nl_a, aes(x, y)) +
  geom_point(size = 4) +
  geom_smooth(method = "lm", formula = y ~ x + I(x^2) + I(x^3)) +
  labs(title = bquote(italic(y) == beta[0] + beta[1] * italic(x) + beta[2] * italic(x) ^ 2 + beta[3] * italic(x) ^ 3))
```

&lt;img src="index_files/figure-html/3-poly-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
ggplot(sim_nl_a, aes(x, y)) +
  geom_point(size = 4) +
  geom_smooth(method = "lm", formula = y ~ x + I(x^2) + I(x^3) + I(x^4) + I(x^5) + I(x^6) + I(x^7) + I(x^8) + I(x^9) + I(x^10)) +
  labs(title = bquote(italic(y) == beta[0] + beta[1] * italic(x) + beta[2] * italic(x) ^ 2 + beta[3] * italic(x) ^ 3 + beta[4] * italic(x) ^ 4 + beta[5] * italic(x) ^ 5 + beta[6] * italic(x) ^ 6 + beta[7] * italic(x) ^ 7 + beta[8] * italic(x) ^ 8 + beta[9] * italic(x) ^ 9 + beta[10] * italic(x) ^ 10))
```

&lt;img src="index_files/figure-html/10-poly-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
ggplot(line, aes(x, y)) +
  geom_point(size = 4) +
  scale_x_continuous(breaks = 1:10) +
  labs(title = bquote(italic(y) == beta[0] + beta[1] * italic(x) + beta[2] * italic(x) ^ 2 + beta[3] * italic(x) ^ 3 + beta[4] * italic(x) ^ 4 + beta[5] * italic(x) ^ 5 + beta[6] * italic(x) ^ 6 + beta[7] * italic(x) ^ 7 + beta[8] * italic(x) ^ 8 + beta[9] * italic(x) ^ 9 + beta[10] * italic(x) ^ 10)) +
  ylim(1, 18)
```

&lt;img src="index_files/figure-html/10-poly-2-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
ggplot(line, aes(x, y)) +
  geom_point(size = 4) +
  geom_smooth(method = "lm", se = FALSE, formula = y ~ x + I(x^2) + I(x^3) + I(x^4) + I(x^5) + I(x^6) + I(x^7) + I(x^8) + I(x^9) + I(x^10)) +
  scale_x_continuous(breaks = 1:10) +
  labs(title = bquote(italic(y) == beta[0] + beta[1] * italic(x) + beta[2] * italic(x) ^ 2 + beta[3] * italic(x) ^ 3 + beta[4] * italic(x) ^ 4 + beta[5] * italic(x) ^ 5 + beta[6] * italic(x) ^ 6 + beta[7] * italic(x) ^ 7 + beta[8] * italic(x) ^ 8 + beta[9] * italic(x) ^ 9 + beta[10] * italic(x) ^ 10)) +
  ylim(1, 18)
```

&lt;img src="index_files/figure-html/10-poly-21-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

layout: false

## Generalised additive models

* **G**enrealised **A**dditive **M**odel**s** (GAMs)

* `\(y = f(x)\)`
    * `\(f(x)\)` = some function of `\(x\)` (or *smooth function*)

---

## Smooth terms

* LMs have **parametric terms**
    * `\(\beta_nx_n\)`
    * `x` in `R`
    * For linear effects.

--

* GAMs add (non-parametric) **smooth terms** (or simply smooths, also smoothers):
    * `\(f(x)\)`
    * `s(x)` in `R`
    * For non-linear effects.

--

* `library(mgcv); gam(y ~ s(x), data)`: `\(y\)` as *some* function of `\(x\)`

---

## Smoothing splines, basis, basis functions

* Smooths in GAMs are **smoothing splines**.
    * Splines are defined piecewise with a set of polynomials.

--

* The set of polynomials is called a **basis**.
    * The basis is composed of **basis functions** (the polynomials).
    * The number of basis functions is called the **dimension of the basis** (`k` in mgcv).

--

* A spline is the sum of the products of each basis function and its coefficient.

---

## Basis functions and knots


```r
par(mfrow = c(1, 2))

simple &lt;- gam(y ~ s(x, bs = "cr", k = 10), data = sim_nl_a)

X &lt;- predict(
  simple,
  newdata = data.frame(x = sim_nl_a$x),
  type = "lpmatrix"
)[,2:10]

plot(sim_nl_a$x, X[, 1], type = "n", ylim = c(-2, 3), xlab = "x", ylab = "y")
for (i in 1:ncol(X)) {
  lines(sim_nl_a$x, X[, i], col = i, lw = 1)
}

X2 &lt;- X %*% diag(coef(simple)[2:10])
plot(
  sim_nl_a$x,
  predict(simple, newdata = data.frame(x = sim_nl_a$x)) -
    coef(simple)[1],
  type = "n",
  ylim = c(-8, 3),
  xlab = "x", ylab = "y"
)
for (i in 1:ncol(X2)) {
  lines(sim_nl_a$x, X2[, i], col = i, lw = 1)
}
lines(
  sim_nl_a$x,
  predict(simple, newdata = data.frame(x = sim_nl_a$x)) -
    coef(simple)[1],
  lw = 3
)
```

&lt;img src="index_files/figure-html/basis-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

## Smoothing parameter

* Wiggliness is related to **number of basis functions**.
    * more basis functions, more wiggliness (less smoothing).

--

* The **smoothing parameter** penalises wiggliness.
    * High values = less wiggliness (more smoothing).
    * This is estimated from the data.

---

## Smoothing splines

* There are **several kinds of splines**.
    * Each has its own basis functions.

* Most common splines:
    * *Thin plate regression splines*.
    * *Cubic regression splines*.

* For more info, run `?smooth.terms`.

---

layout: true

## A simple GAM

---


```r
simple &lt;- gam(
  y ~ 
    # Cubic regression spline.
    # k is the dimension of the basis.
    s(x, bs = "cr", k = 10),
  data = sim_nl_a
)
```

---


```r
summary(simple)
```

```
## 
## Family: gaussian 
## Link function: identity 
## 
## Formula:
## y ~ s(x, bs = "cr", k = 10)
## 
## Parametric coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept)  10.1165     0.1028   98.37   &lt;2e-16
## 
## Approximate significance of smooth terms:
##        edf Ref.df     F p-value
## s(x) 6.939   8.01 38.69  &lt;2e-16
## 
## R-sq.(adj) =  0.755   Deviance explained = 77.2%
## GCV = 1.1593  Scale est. = 1.0681    n = 101
```

---


```r
predict_gam(simple, series = "x", length_out = 30) %&gt;% plot()
```

&lt;img src="index_files/figure-html/simple-10-plot-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
simple_5 &lt;- gam(y ~ s(x, bs = "cr", k = 5), data = sim_nl_a)
predict_gam(simple_5, series = "x", length_out = 30) %&gt;% plot()
```

&lt;img src="index_files/figure-html/simple-5-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

layout: false
layout: true

## Comparing groups

---


```r
ggplot(sim_nl, aes(x, y, colour = group)) +
  geom_point(size = 4)
```

&lt;img src="index_files/figure-html/nl-plot-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
ggplot(sim_nl, aes(x, y, colour = group)) +
  geom_point(size = 4, alpha = 0.3) +
  geom_smooth(se = FALSE, method = "gam")
```

&lt;img src="index_files/figure-html/nl-smooth-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

* `by`-variables with ordered factors


```r
compare &lt;- gam(
  y ~
    group +
    s(x, bs = "cr", k = 5) +
    s(x, bs = "cr", k = 5, by = group),
  data = sim_nl
)
```

---

To use `by`-variables with ordered factors:

* Change factor to an **ordered factor**.

* Change factor contrast to **treatment contrast** (`contr.treatment`).
    * The default in ordered factors is `contr.poly`, this won't work.
    
* Include the factor as a **parametric term**.

* Include a **reference smooth** and a **difference smooth** with the `by`-variable.

---


```r
sim_nl &lt;- sim_nl %&gt;%
  mutate(group_o = ordered(group, levels = c("a", "b")))
contrasts(sim_nl$group_o) &lt;- "contr.treatment"
```

---


```r
compare &lt;- gam(
  y ~
    # parametric term
    group_o +
    # reference smooth
    s(x, bs = "cr", k = 5) +
    # difference smooth
    s(x, bs = "cr", k = 5, by = group_o),
  data = sim_nl
)
```

---



```r
summary(compare)
```

```
## 
## Family: gaussian 
## Link function: identity 
## 
## Formula:
## y ~ group_o + s(x, bs = "cr", k = 5) + s(x, bs = "cr", k = 5, 
##     by = group_o)
## 
## Parametric coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept)  10.1165     0.1096   92.34   &lt;2e-16
## group_ob     -2.4947     0.1549  -16.10   &lt;2e-16
## 
## Approximate significance of smooth terms:
##                 edf Ref.df     F p-value
## s(x)          4.000  4.000 64.99  &lt;2e-16
## s(x):group_ob 3.576  3.896 39.67  &lt;2e-16
## 
## R-sq.(adj) =  0.873   Deviance explained = 87.8%
## GCV = 1.2725  Scale est. = 1.2122    n = 202
```

---


```r
library(tidygam)
predict_gam(compare, series = "x", length_out = 30) %&gt;% plot(comparison = "group_o")
```

&lt;img src="index_files/figure-html/plot-smooth-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

layout: false
class: center middle inverse

# HANDS-ON 1

---

layout: true

## Comparing across groups (interactions)

---

* Technically, GAMs **don't allow interactions**.

  * They are ADDITIVE (interactions require multiplication).

--

* We can get interaction-like comparisons by creating **factor interactions** and using them as `by`-variables.

---

Let's use the ACCH data frame from the hands-on.


```r
acch &lt;- read_delim("data/ACCH.txt") %&gt;%
  mutate(
    StimSlide.RT = StimSlide.RT/1000,
    RT_log = log(StimSlide.RT),
    ACC = ifelse(StimSlide.ACC == 0, "incorrect", "correct")
  )

acch
```

```
## # A tibble: 4,796 × 13
##    Subject Group       Trial Condi…¹  item Remove StimS…² StimS…³ Struc…⁴ Number
##      &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt; 
##  1     202 monolingual     1       1     1 no           1    6.21 Subject Match 
##  2     202 monolingual     1       1     2 no           1    3.89 Subject Match 
##  3     202 monolingual    15       1     3 no           0    4.37 Subject Match 
##  4     202 monolingual    26       1     4 no           1    3.70 Subject Match 
##  5     202 monolingual    15       1     5 no           1    5.63 Subject Match 
##  6     202 monolingual    33       1     6 no           1    3.78 Subject Match 
##  7     202 monolingual    23       1     7 no           1    4.68 Subject Match 
##  8     202 monolingual    26       1     8 no           1    3.78 Subject Match 
##  9     202 monolingual    28       1     9 no           1    4.21 Subject Match 
## 10     202 monolingual    24       1    10 no           1    5.42 Subject Match 
## # … with 4,786 more rows, 3 more variables: First_NP &lt;chr&gt;, RT_log &lt;dbl&gt;,
## #   ACC &lt;chr&gt;, and abbreviated variable names ¹​Condition, ²​StimSlide.ACC,
## #   ³​StimSlide.RT, ⁴​Structure
```

---

Now, let's create a factor interaction between `Group` and `Structure`.

We also need to make it into an ordered factor with treatment contrasts.


```r
acch &lt;- acch %&gt;%
  mutate(
    Gr_St = as.ordered(interaction(Group, Structure))
  )
contrasts(acch$Gr_St) &lt;- "contr.treatment"

head(acch$Gr_St)
```

```
## [1] monolingual.Subject monolingual.Subject monolingual.Subject
## [4] monolingual.Subject monolingual.Subject monolingual.Subject
## attr(,"contrasts")
## [1] contr.treatment
## 4 Levels: bilingual.Object &lt; monolingual.Object &lt; ... &lt; monolingual.Subject
```

---


```r
rt_gam &lt;- gam(
  RT_log ~ Gr_St + s(Trial) + s(Trial, by = Gr_St),
  data = acch
)
```

---


```r
summary(rt_gam)
```

```
## 
## Family: gaussian 
## Link function: identity 
## 
## Formula:
## RT_log ~ Gr_St + s(Trial) + s(Trial, by = Gr_St)
## 
## Parametric coefficients:
##                          Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept)               1.64593    0.01194 137.842  &lt; 2e-16
## Gr_Stmonolingual.Object  -0.04542    0.01562  -2.908  0.00365
## Gr_Stbilingual.Subject   -0.09169    0.01678  -5.466 4.85e-08
## Gr_Stmonolingual.Subject -0.10281    0.01551  -6.629 3.76e-11
## 
## Approximate significance of smooth terms:
##                                     edf Ref.df     F p-value
## s(Trial)                          1.000  1.000 1.110   0.292
## s(Trial):Gr_Stmonolingual.Object  4.026  4.966 1.115   0.328
## s(Trial):Gr_Stbilingual.Subject   3.285  4.070 1.830   0.125
## s(Trial):Gr_Stmonolingual.Subject 2.342  2.918 1.938   0.122
## 
## R-sq.(adj) =  0.0145   Deviance explained = 1.73%
## GCV = 0.13978  Scale est. = 0.13935   n = 4796
```

---


```r
# library(tidygam)
predict_gam(rt_gam, series = "Trial", length_out = 50) %&gt;%
  plot(comparison = "Gr_St")
```

&lt;img src="index_files/figure-html/rt-gam-plot-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
predict_gam(rt_gam, series = "Trial", length_out = 50,
            separate = list(Gr_St = c("Group", "Structure"))) %&gt;%
  plot(comparison = "Group") +
  facet_grid(Structure ~ .)
```

&lt;img src="index_files/figure-html/rt-gam-plot-2-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
get_difference(
  rt_gam, "Trial", list(Gr_St = c("bilingual.Object", "monolingual.Object"))
) %&gt;%
  plot()
```

&lt;img src="index_files/figure-html/rt-gam-diff-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
get_difference(
  rt_gam, "Trial", list(Gr_St = c("bilingual.Object", "bilingual.Subject"))
) %&gt;%
  plot()
```

&lt;img src="index_files/figure-html/rt-gam-diff-2-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
get_difference(
  rt_gam, "Trial", list(Gr_St = c("monolingual.Object", "monolingual.Subject"))
) %&gt;%
  plot()
```

&lt;img src="index_files/figure-html/rt-gam-diff-3-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

layout: false
layout: true

## Tensor product smooths and interactions

---

|                 | LM      | GAM                    |
|-----------------|---------|------------------------|
| Num × cat       | `num:cat` | `s(num, by = "cat")`     |
| Num × cat × cat | `num:cat:cat` | `s(num, by = "cat_cat")` |

---

|                 | LM      | GAM                    |
|-----------------|---------|------------------------|
| Num × cat       | `num:cat` | `s(num, by = cat)`     |
| Num × cat × cat | `num:cat:cat` | `s(num, by = cat_cat)` |
| Num × num       | `num:num` | `te(num, num)`           |
| Num × num × cat | `num:num:cat` | `te(num, num, by = cat)` |

---

* **Tensor product smooths** are smooths that create interactions between two numeric predictors.

* Tensor product smooths are specified with `te()` or `ti()`.

  * `ti(x) + ti(y) + ti(x, y)`.
  * `te(x, y)`.

--

Note that if the two numeric predictors are on the same scale (isotropic), you can use `s()` instead of `te/ti()`. Coordinates are such type of predictors.

---


```r
vowels &lt;- read_csv("data/vowels.csv")
vowels
```

```
## # A tibble: 11,565 × 12
##    speaker index    word  time_p…¹    f1    f2    f3    f0 durat…² vowel voicing
##    &lt;chr&gt;   &lt;chr&gt;    &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  
##  1 it01    it01-001 pugu         1  308.  797. 2280.  137.    95.2 u     voiced 
##  2 it01    it01-001 pugu         2  315.  779. 2124.  134.    95.2 u     voiced 
##  3 it01    it01-001 pugu         3  316.  786. 2314.  134.    95.2 u     voiced 
##  4 it01    it01-001 pugu         4  314.  789. 2374.  135.    95.2 u     voiced 
##  5 it01    it01-001 pugu         5  313.  737. 2307.  137.    95.2 u     voiced 
##  6 it01    it01-001 pugu         6  305.  717. 2315.  138.    95.2 u     voiced 
##  7 it01    it01-001 pugu         7  291.  713. 2318.  138.    95.2 u     voiced 
##  8 it01    it01-001 pugu         8  280.  733. 2308.  137.    95.2 u     voiced 
##  9 it01    it01-001 pugu         9  287.  784. 2329.  136.    95.2 u     voiced 
## 10 it01    it01-002 pada         1  651. 1119. 2155.  120.   139.  a     voiced 
## # … with 11,555 more rows, 1 more variable: place &lt;chr&gt;, and abbreviated
## #   variable names ¹​time_point, ²​duration
```


---


```r
f0_gam &lt;- gam(
  f0 ~ 
    ti(time_point) + ti(duration) + ti(time_point, duration),
  data = vowels
)
```

---


```r
predict_gam(f0_gam) %&gt;%
  plot(series = "time_point", comparison = "duration")
```

&lt;img src="index_files/figure-html/f0-gam-plot-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
predict_gam(f0_gam, values = list(duration = c(50, 100, 150, 200))) %&gt;%
  plot(series = "time_point", comparison = "duration")
```

&lt;img src="index_files/figure-html/f0-gam-plot-2-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
predict_gam(f0_gam) %&gt;%
  plot(
    series = c("time_point", "duration"),
    raster_interp = TRUE
  )
```

&lt;img src="index_files/figure-html/f0-gam-plot-3-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

layout: false
class: center middle inverse

# HANDS-ON 2

---

layout: true

## Random effects with factor smooths

---

* Only **fixed effects** so far...

* **G**eneralised **A**dditive **M**ixed **M**odel (GAMM)

* Include a **random smooth** term with the **factor smooth interaction** as basis.

---

* **Factor smooth interaction**:
    * `bs = "fs"`.
    * A smooth is fitted at each level of a factor.

* The random effect variable *needs to be a factor*.

* `s(Trial, Subject, bs = "fs", m = 1)`

---


```r
acch &lt;- acch %&gt;%
  mutate(Structure_o = as.ordered(Structure))

contrasts(acch$Structure_o) &lt;- "contr.treatment"
```

---


```r
rt_gam_2 &lt;- gam(
  RT_log ~
    Gr_St + s(Trial) + s(Trial, by = Gr_St) +
    s(Trial, Subject, bs = "fs", m = 1) +
    s(Trial, Subject, by = Structure_o, bs = "fs", m = 1),
  data = acch
)
```

---


```r
summary(rt_gam_2)
```

```
## 
## Family: gaussian 
## Link function: identity 
## 
## Formula:
## RT_log ~ Gr_St + s(Trial) + s(Trial, by = Gr_St) + s(Trial, Subject, 
##     bs = "fs", m = 1) + s(Trial, Subject, by = Structure_o, bs = "fs", 
##     m = 1)
## 
## Parametric coefficients:
##                           Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept)               1.618266   0.037652  42.979   &lt;2e-16
## Gr_Stmonolingual.Object   0.001025   0.062932   0.016   0.9870
## Gr_Stbilingual.Subject   -0.023624   0.052270  -0.452   0.6513
## Gr_Stmonolingual.Subject -0.104227   0.046724  -2.231   0.0257
## 
## Approximate significance of smooth terms:
##                                         edf  Ref.df     F p-value
## s(Trial)                             1.6225  1.8555 0.177   0.821
## s(Trial):Gr_Stmonolingual.Object     1.0000  1.0000 0.000   0.988
## s(Trial):Gr_Stbilingual.Subject      1.7496  2.2769 0.884   0.373
## s(Trial):Gr_Stmonolingual.Subject    0.6667  0.6667 0.041   0.869
## s(Trial,Subject)                    19.8833 24.2136 3.472  &lt;2e-16
## s(Trial,Subject):Structure_oSubject  1.6667  1.6667 0.929   0.279
## 
## Rank: 96/97
## R-sq.(adj) =  0.0301   Deviance explained = 3.61%
## GCV = 0.13803  Scale est. = 0.13714   n = 4796
```


---


```r
predict_gam(
  rt_gam_2,
  separate = list(Gr_St = c("Group", "Structure")),
  exclude_terms = c("s(Trial,Subject)", "s(Trial,Subject):Structure_oSubject")
) %&gt;%
  select(-Structure_o) %&gt;%
  distinct() %&gt;%
  plot(series = "Trial", comparison = "Structure") +
  facet_grid(~ Group)
```

&lt;img src="index_files/figure-html/rt-gam-2-plot-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---


```r
get_difference(
  rt_gam_2, "Trial", list(Gr_St = c("bilingual.Object", "bilingual.Subject"))
) %&gt;%
  plot()
```


---


```r
get_difference(
  rt_gam_2, "Trial", list(Gr_St = c("monolingual.Object", "monolingual.Subject"))
) %&gt;%
  plot()
```

&lt;img src="index_files/figure-html/rt-gam-2-diff-2-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

layout: false

## GAMs with binomial/Bernoulli families

---


```r
acc_gam_2 &lt;- gam(
  StimSlide.ACC ~
    Gr_St + s(Trial) + s(Trial, by = Gr_St) +
    s(Trial, Subject, bs = "fs", m = 1),
  data = acch,
  family = binomial()
)
```

---


```r
summary(acc_gam_2)
```

```
## 
## Family: binomial 
## Link function: logit 
## 
## Formula:
## StimSlide.ACC ~ Gr_St + s(Trial) + s(Trial, by = Gr_St) + s(Trial, 
##     Subject, bs = "fs", m = 1)
## 
## Parametric coefficients:
##                          Estimate Std. Error z value Pr(&gt;|z|)
## (Intercept)               2.82414    0.67629   4.176 2.97e-05
## Gr_Stmonolingual.Object  -1.80257    1.12546  -1.602    0.109
## Gr_Stbilingual.Subject    2.11279    0.24017   8.797  &lt; 2e-16
## Gr_Stmonolingual.Subject  0.05691    1.13643   0.050    0.960
## 
## Approximate significance of smooth terms:
##                                      edf Ref.df Chi.sq  p-value
## s(Trial)                           1.000  1.000  0.003 0.956402
## s(Trial):Gr_Stmonolingual.Object   5.157  6.261  5.894 0.447924
## s(Trial):Gr_Stbilingual.Subject    1.000  1.000  4.986 0.025566
## s(Trial):Gr_Stmonolingual.Subject  5.132  6.214  9.032 0.186108
## s(Trial,Subject)                  19.048 23.150 55.660 0.000175
## 
## R-sq.(adj) =  0.0722   Deviance explained = 12.8%
## UBRE = -0.45342  Scale est. = 1         n = 4796
```


---


```r
predict_gam(
  acc_gam_2,
  separate = list(Gr_St = c("Group", "Structure")),
  tran_fun = plogis,
  exclude_terms = "s(Trial,Subject)",
  length_out = 30
) %&gt;%
  plot(series = "Trial", comparison = "Structure") +
  facet_grid(~ Group)
```

&lt;img src="index_files/figure-html/acc-gam-2-plot-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---

layout: false
class: center middle inverse

# HANDS-ON 3
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9",
"countIncrementalSlides": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
